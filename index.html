<!DOCTYPE html>
<html>
  <head>
    <title>about:jisp</title>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="Mitranim">
    <link rel="stylesheet" href="css/app.css">
    <link rel="stylesheet" href="http://netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">
    <script src="js/jisp.js" charset="utf-8"></script>
    <script src="js/app.js" charset="utf-8"></script>
    <!--HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries
    -->
    <!--
    [if lt IE 9]>
    <script src='https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js' </script>
    <script src='https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js' </script>
    <![endif]
    
    -->
  </head>
  <body id="top" ng-app="jispApp" ng-controller="MainControl">
    <div role="navigation" class="navbar navbar-default">
      <div class="container">
        <div class="navbar-header"><a href="/" class="navbar-brand">jisp</a></div>
        <ul class="nav navbar-nav">
          <li><a href="https://github.com/Mitranim/jisp" class="fa fa-github"> git</a></li>
        </ul>
      </div>
    </div>
    <div class="container">
      <div class="row">
        <div class="col-lg-9">
          <p class="lead">Jisp is a programmable language that compiles to JavaScript.</p><p>It’s simpler, terser, and more powerful than JS. Its macro system lets you treat code as data and write functions that write code for you. Jisp’s extremely simple syntax protects against common JS pitfalls, and it abstracts away some legacy details, helping avoid errors and keep your code short.</p>
<p>See the <a href="#why">why jisp</a> section for a gist of why you should use it.</p>
<p>The jisp compiler is itself written in jisp. See the <a href="https://github.com/Mitranim/jisp">sourcecode on git</a>.</p>
<p>You can contribute to this documentation by sending pull requests to the <a href="https://github.com/Mitranim/jisp/tree/gh-pages">gh-pages</a> branch of the project repo.</p>
<blockquote>
<p>All examples on this page are interactive: edit the jisp to see changes. The JavaScript snippets are compiled in your browser. If you don’t see them, make sure JS is enabled and refresh the page.</p>
</blockquote>

          <h2>Interactive playground</h2>
          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 36em; min-height: 36em;" model-init="exampleCode" autofocus="" class="form-control form-code left">(mac task name ...args (do 
  (= pipeline `(do (handle (,(args.shift) ,(args.shift)))))
  (while (&gt; args.length 0) (do
    (= left  (args.shift)
       right (args.shift))
    (pipeline.push `(.pipe (handle (,left ,right))))))
  `(gulp.task ,name (fn ,pipeline))))

(task       'js'
  gulp.src  jsFiles
  conc      'deps.js'
  uglify    (mangle: no)
  gulp.dest 'public/js/tmp/')

(task       'jisp'
  gulp.src  jispFiles
  conc      'app.js'
  jisp      ()
  uglify    (mangle: no)
  gulp.dest 'public/js/tmp/')

; try your own macro call here

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 36em; min-height: 36em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 36em; min-height: 36em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p>Example of dynamically constructing code with a macro.</p>

          <h2 id="installation">Installation and Usage</h2><p>Get <a href="http://nodejs.org">Node.js</a>. This will give you the local <code>node</code> runtime and the <code>npm</code> package manager. Install jisp from npm:</p>
<pre><code>$ npm install -g jisp
</code></pre><p>Alternatively, download the source, run <code>npm install</code> to get the dependencies, and use <code>./bin/jisp</code> and <code>./jisp/jisp.js</code> as entry points.</p>
<p>Require in Node, registering the file extension:</p>
<pre><code>require(&#39;jisp/register&#39;);
</code></pre><p>This allows you to <code>require</code> jisp scripts directly from your code, like so:</p>
<pre><code>require(&#39;./app.jisp&#39;);
</code></pre><p>Launch an interactive REPL:</p>
<pre><code>$ jisp
jisp&gt;
</code></pre><p>Compile a file or directory:</p>
<pre><code>$ jisp -c &lt;file&gt;
</code></pre><p>Stream-compile with <a href="https://github.com/Mitranim/gulp-jisp">gulp-jisp</a>.</p>
<p>While not recommended for production, jisp can be directly used in the browser. Include the <code>browser/jisp.js</code> file with your webpage. It registers the <code>text/jisp</code> script type to automatically compile and run jisp scripts loaded with <code>src</code> or included in script tags. It also exposes a global object with the <code>compile</code> and <code>eval</code> methods for jisp code. This is how this documentation is implemented.</p>
<p>Super basic Sublime Text build system (OS X):</p>
<ul>
<li><em>Tools</em> &gt; <em>Build System</em> &gt; <em>New Build System</em></li>
<li>put line: <code>&quot;cmd&quot;: [&quot;jisp&quot;, &quot;$file&quot;]</code></li>
<li>save to: <code>~/Library/Application Support/Sublime Text 3/Packages/User</code></li>
</ul>

          <h2 id="code-structure">Code Structure</h2><p><em>Jisp code consists of nested arrays</em>. To be easier on the eyes, they’re delimited with parentheses <code>()</code> instead of brackets. Individual elements are separated by whitespace rather than commas. This documentation refers to them as <em>lists</em>, but it’s just arrays.</p>

          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 24em; min-height: 24em;" model-init="exampleCode" class="form-control form-code left">; list that compiles to a function call
(console.log 'Fire in the house!')

; quoted list — array literal
`(1 NaN 'bison')

; empty array literal
`()

; assignment (name binding)
(= myVar 'myValue')

; function definition
(fn x (alert x))

; see other special forms below

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 24em; min-height: 24em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 24em; min-height: 24em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p>Object literals are also delimited with parentheses, elements separated by whitespace rather than commas. This documentation often refers to object literals as <em>hash tables</em> to discern them from objects in general.</p>

          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 10em; min-height: 10em;" model-init="exampleCode" class="form-control form-code left">; object literal (hash table)
(place: 'tavern' drink: 'rum')

; empty object literal
(:)

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 10em; min-height: 10em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 10em; min-height: 10em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p>Identifiers and literals without parentheses are called <em>atoms</em>:</p>

          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 28em; min-height: 28em;" model-init="exampleCode" class="form-control form-code left">; number
Infinity

; string literal
'February'

; multiline string
'split across
two lines'

; regex literal
/!@#$%/

; name
parseInt

; special name
null undefined true

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 28em; min-height: 28em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 28em; min-height: 28em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p>Strings in jisp are multiline.</p>
<p>Parentheses in the jisp code are <strong>not cosmetic</strong>. Your code <em>consists</em> of arrays. This allows to easily deconstruct and construct it when using macros. We’ll get to this in the <a href="#macros">Macros</a> section.</p>
<p>Jisp is mostly whitespace-agnostic. Elements in lists and hash tables are separated by whitespace, but other than that, jisp is completely insensitive to whitespace and indentation, relying on parentheses as delimiters. Forms can contain linebreaks.</p>
<p>In a non-quoted list, the first element is considered a function, and the list compiles as a function call:</p>

          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 10em; min-height: 10em;" model-init="exampleCode" class="form-control form-code left">; function call
(alert 'A dragon cometh!')

; nested call
(isNaN (parseInt Infinity))

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 10em; min-height: 10em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 10em; min-height: 10em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p>In fact, even operators are considered functions and use the prefix notation. This allows them to take multiple arguments:</p>

          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 12em; min-height: 12em;" model-init="exampleCode" class="form-control form-code left">; operator expression
(&amp; 2 3 4)
(+ 'using jisp' 'you’re' 'awesome')

; nested operator expressions
(* 4 5 (- 3 6 10) (^ 1 5))

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 12em; min-height: 12em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 12em; min-height: 12em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p><strong>[NYI]</strong> Planned feature: you’ll be able to pass operators around like any other function:</p>

          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 8em; min-height: 8em;" model-init="exampleCode" class="form-control form-code left">(= x `(1 2 3 4))
(x.sort &lt;)        ; result: (4 3 2 1)

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 8em; min-height: 8em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 8em; min-height: 8em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p>Not all lists are function calls. Some are <em>special forms</em> with their own resolution rules. This includes assignment, quoting, function definitions, conditionals, loops, and JS keywords.</p>

          <h2 id="everything-exp">Everything an Expression</h2><p>Most languages distinguish statements and expressions. An expression is a piece of code with a value, something you can assign or return from a function. Statements have side effects but no value. In jisp, everything is an expression. It helps you write <a href="http://en.wikipedia.org/wiki/Functional_programming#Coding_styles">functional</a> code, avoiding unnecessary data fiddling.</p>
<p>An atom such as a number literal, a string literal, or identifier, resolves to itself.</p>
<p>A hash table resolves to itself, with its values resolved individually.</p>
<p>Lists resolve by special rules:</p>
<ul>
<li>An unquoted empty list <code>()</code> (not <code>`()</code>) resolves to nothing.</li>
<li>Special forms starting with a keyword like <code>=</code>, <code>def</code>, and others, resolve by their own special rules.</li>
<li>Lists starting with a macro name resolve as macro calls at compile time.</li>
<li>Everything else resolves as a function call.</li>
</ul>
<p>Examples:</p>

          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 20em; min-height: 20em;" model-init="exampleCode" class="form-control form-code left">; name binding
(= x 10)

; anonymous function (lambda)
(fn x (/ x 10))

; `if` conditional
(if false (/ 1 0) (^ 4 6))

; function definition and call
((fn y (+ 10 y)) 13)

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 20em; min-height: 20em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 20em; min-height: 20em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p>Inside a nested form, forms are resolved left-to-right, inner-to-outer, just like you’d expect.</p>

          <h2 id="quoting">Quoting</h2><p>If lists resolve as function calls, how do you write array literals? The answer is quoting. The special form <code>(quote x)</code> prevents the list <code>x</code> from being resolved, letting it remain an array. Prepending a list with <code>` </code> is shorthand syntax:</p>

          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 14em; min-height: 14em;" model-init="exampleCode" class="form-control form-code left">; without quote
(1 2 3)

; with quote
(quote (1 2 3))

; shorthand
`(1 2 3)

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 14em; min-height: 14em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 14em; min-height: 14em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p>Directly quoting a non-primitive atom (name or string) stringifies it:</p>

          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 10em; min-height: 10em;" model-init="exampleCode" class="form-control form-code left">; name
`myvar

; string
`'mystring'

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 10em; min-height: 10em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 10em; min-height: 10em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p>Which is convenient for macros. Atoms in macro call arguments are quoted implicitly.</p>
<p>Quoting implicitly propagates to inner lists:</p>

          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 10em; min-height: 10em;" model-init="exampleCode" class="form-control form-code left">; without quote
(+ (^ 2 1) (is 'π' 'Ω'))

; with quote, invalid javascript
`(+ (^ 2 1) (is 'π' 'Ω'))

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 10em; min-height: 10em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 10em; min-height: 10em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p>To let an element resolve, <em>unquote</em> it with a comma <code>,</code>:</p>

          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 10em; min-height: 10em;" model-init="exampleCode" class="form-control form-code left">; without unquote: invalid javascript
`((* 2 3) (is true false))

; with unquote: valid javascript
`(,(* 2 3) ,(is true false))

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 10em; min-height: 10em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 10em; min-height: 10em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p>Aside from writing array literals, quoting and unquoting is primarily used in macros. See the <a href="#macros">Macros</a> section below.</p>

          <h2 id="blocks">Blocks and Chaining</h2><p>If everything is an expression and all forms are lists, how do you write consequtive commands? By wrapping them in the special form <code>do</code>:</p>

          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 10em; min-height: 10em;" model-init="exampleCode" class="form-control form-code left">(def elongate str
  (do (+= str str)
      (console.log 'duplicated:' str)
      str))

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 10em; min-height: 10em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 10em; min-height: 10em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p>On compile, a jisp file is implicitly wrapped in a top-level <code>do</code> form.</p>
<p><code>do</code> resolves to the value of its last form. It’s a requirement for chaining methods:</p>

          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 20em; min-height: 20em;" model-init="exampleCode" class="form-control form-code left">; take last value
(console.log (do (= bugs `())
  (bugs.push 'butterfree')
  (bugs.push 'beedrill')
  bugs))

; assign result of chaining methods
(= str ',…x')
(= grated (do str
   (.replace /…/g ' … ')
   (.replace /,/g ' , ')
   (.trim)))

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 20em; min-height: 20em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 20em; min-height: 20em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p><strong>Note</strong>: <code>do</code> is the <strong>only</strong> jisp expression that can consist of multiple forms. The body of each function, loop, etc. is always a single form, and requires a <code>do</code> to include multiple expressions.</p>

          <h2 id="object-props">Object Properties</h2><p>As you’d expect, object properties are referenced with the <code>.dot</code> or <code>[bracket]</code> notation:</p>

          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 12em; min-height: 12em;" model-init="exampleCode" class="form-control form-code left">(= bunny (bouncy: true fluffy: false))
bunny.bouncy
bunny['fluffy']

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 12em; min-height: 12em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 12em; min-height: 12em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p>Dot and bracket notation is a syntax shortcut to getting a property of an object. Internally, jisp uses the <code>(get obj prop)</code> special form:</p>

          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 6em; min-height: 6em;" model-init="exampleCode" class="form-control form-code left">(get bunny bouncy)
(get bunny 'fluffy')

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 6em; min-height: 6em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 6em; min-height: 6em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p><strong>[NYI]</strong> You’ll be able to access properties of resolved forms:</p>
<pre><code>(console.log (String 113).length)  ; 3
</code></pre><p>Until it’s implemented, use the <code>get</code> form, and <code>do</code> for methods (below).</p>

          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 4em; min-height: 4em;" model-init="exampleCode" class="form-control form-code left">(get (String 113) length)

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 4em; min-height: 4em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 4em; min-height: 4em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p>To chain methods, wrap them in a <code>do</code> form:</p>

          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 12em; min-height: 12em;" model-init="exampleCode" class="form-control form-code left">(do cartoonSnake
   (.crawlForward 10)
   (.turnLeft)
   (['crawlForward'] 5)
   (.eat 'bunny')
   (.elongate food.weight))

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 12em; min-height: 12em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 12em; min-height: 12em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code>
          <h2 id="functions">Functions</h2><p>Jisp mirrors JavaScript function facilities 1-1 and adds some more.</p>

          <h3 id="definition">Definition</h3><p>Named function:</p>
<pre><code>(def &lt;name&gt; [&lt;... params&gt;] [&lt;body&gt;])
</code></pre>
          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 8em; min-height: 8em;" model-init="exampleCode" class="form-control form-code left">(def fact x
  (if (is x 0) 1
      (* x (fact (- x 1)))))

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 8em; min-height: 8em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 8em; min-height: 8em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p>Anonymous function (sometimes called <em>lambda</em>):</p>
<pre><code>(fn [&lt;... params&gt;] [&lt;body&gt;])
</code></pre>
          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 12em; min-height: 12em;" model-init="exampleCode" class="form-control form-code left">(fn first second (+ first second))

(fn returnMe)

(fn)

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 12em; min-height: 12em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 12em; min-height: 12em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code>
          <h3 id="call-return">Calling and Returning</h3><p>A function call is a list starting with the function’s name or with a form that resolves to a function:</p>

          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 14em; min-height: 14em;" model-init="exampleCode" class="form-control form-code left">(= ringMyBell (fn bell (console.log bell)))

(ringMyBell '\x07')

((fn x (+ 'Hello ' x)) 'World!')

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 14em; min-height: 14em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 14em; min-height: 14em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p>A function returns the resolved value of its body. You almost never need to return values manually:</p>

          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 18em; min-height: 18em;" model-init="exampleCode" class="form-control form-code left">(def numerify x
  (if (isNaN (Number x))
      (do (console.log 'not a number:' x)
          NaN)
      (Number x)))

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 18em; min-height: 18em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 18em; min-height: 18em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p>It’s often best to keep each function’s body a single conditional tree with branches ending in return values.</p>
<p>Inside a function’s body, <code>#</code> (<strong>NYI</strong>) is an array of the arguments passed to it, and <code>#n</code> refers to an individual argument by order.</p>

          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 6em; min-height: 6em;" model-init="exampleCode" class="form-control form-code left">((fn (* #0 #2)) 3 100 4)

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 6em; min-height: 6em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 6em; min-height: 6em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p>As a side effect of implicit returns, when making a prototype constructor, you need to end it with <code>this</code> as the return value to make the <code>new</code> declarations work.</p>

          <h3 id="lambda">Lambda Syntax</h3><p>Because functions are so cheap in JavaScript, jisp comes with a shorthand syntax for anonymous functions:</p>
<pre><code>{&lt;body&gt;}
</code></pre>
          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 12em; min-height: 12em;" model-init="exampleCode" class="form-control form-code left">{alert 'It’s a dragon!'}

{+ 3 4}

{}

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 12em; min-height: 12em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 12em; min-height: 12em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p>This goes hand in hand with the <code>#</code> notation:</p>

          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 14em; min-height: 14em;" model-init="exampleCode" class="form-control form-code left">(= array `(0 1 2 3))

{* #0 #1}

(array.filter {&gt; #0 1})
                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 14em; min-height: 14em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 14em; min-height: 14em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code>
          <h3 id="let">Let</h3><p><code>let</code> is a short way to declare variables in an isolated scope and run that scope. It resolves to the value returned by its body.</p>
<pre><code>(let [var value [var value ...]] [&lt;body&gt;])
</code></pre>
          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 9em; min-height: 9em;" model-init="exampleCode" class="form-control form-code left">(let health 100
  (console.log health))   ; logs 100

(? health)                ; logs false: out ot scope

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 9em; min-height: 9em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 9em; min-height: 9em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p>Just like assignment, it takes variables in pairs:</p>

          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 10em; min-height: 10em;" model-init="exampleCode" class="form-control form-code left">(let plus  110
     minus -12
     (console.log (^ plus minus)))

(? plus minus)    ; false: out of scope

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 10em; min-height: 10em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 10em; min-height: 10em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p><code>let</code> is currently implemented as a self-executing anonymous function. In the future editions of EcmaScript, it will be changed to use the native <code>let</code> statement with a block.</p>

          <h2 id="assignment">Assignment</h2><p>Like all other forms, assignment uses the prefix notation:</p>
<pre><code>(= var value [... var value])
(= var)
</code></pre>
          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 10em; min-height: 10em;" model-init="exampleCode" class="form-control form-code left">; assign a literal
(= newvar 'some value')

; assign an expression
(= pi (if (is 2 3) NaN Math.PI))
                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 10em; min-height: 10em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 10em; min-height: 10em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p>All assignments in jisp (not just <code>=</code>) automatically hoist <code>var</code> declarations, saving you keystrokes and safeguarding against leaking globals. Variables are only declared if not already in scope. To shadow an outer variable on purpose, use <code>let</code>.</p>
<p>Like many other forms, <code>=</code> takes multiple arguments. It assigns them in pairs. Its resolved value is the last assignment:</p>

          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 9em; min-height: 9em;" model-init="exampleCode" class="form-control form-code left">(= lastest (= first  'Coffee'
              second 'Beer'
              third  'Milk'))

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 9em; min-height: 9em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 9em; min-height: 9em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p>The right hand of an assignment can be an arbitrary form, even a block:</p>

          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 16em; min-height: 16em;" model-init="exampleCode" class="form-control form-code left">(= x (= shifty null
        picky  (if false 'nose up' 'smile')
        dodgy  (try (+ something) 'unsuccessful')))
                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 16em; min-height: 16em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 16em; min-height: 16em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p>Calling <code>=</code> with a single argument merely declares that name if not already in scope:</p>

          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 6em; min-height: 6em;" model-init="exampleCode" class="form-control form-code left">(= emptyVar)

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 6em; min-height: 6em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 6em; min-height: 6em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code>
          <h2 id="destructuring">Destructuring Assignment</h2><p>Assign to a list of identifiers to take apart the right hand side of the assignment and bind its parts:</p>
<pre><code>(= (var0 [... varN]) value)
</code></pre>
          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 8em; min-height: 8em;" model-init="exampleCode" class="form-control form-code left">(= (smaller bigger) `(3 Infinity))

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 8em; min-height: 8em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 8em; min-height: 8em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p>This assignment is positional: <code>[0]</code> <code>[1]</code> and so on. To collect all remaining parts into an element, prefix it with <code>...</code> or <code>…</code>:</p>

          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 10em; min-height: 10em;" model-init="exampleCode" class="form-control form-code left">(= (first ...mid closing) `(4 8 0 3))

mid    ; (8 0)

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 10em; min-height: 10em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 10em; min-height: 10em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p><code>...x</code> and <code>…x</code> is a shortcut to the <code>(spread x)</code> special form, which you can, and sometimes need to, use directly. Spreading is moderately greedy: it takes as many elements as possible, but has lower priority than non-spread identifiers.</p>

          <h2 id="spreading-rest">Spreading and Rest Parameter</h2><p>Borrowed straight from the upcoming EcmaScript 6 specification.</p>

          <h3 id="spread-into-list">Spread Into List</h3><p>In a list, prefix elements with <code>...</code> or <code>…</code> to spread their elements into the list, flattening it:</p>

          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 10em; min-height: 10em;" model-init="exampleCode" class="form-control form-code left">`(1 2 (3 4) (5 6))

`(1 2 ...`(3 4) ...`(5 6))

; (1 2 3 4 5 6)

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 10em; min-height: 10em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 10em; min-height: 10em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code>
          <h3 id="argument-spread">Argument Spread</h3><p>Spread a list into a function call to pass its elements as individual arguments:</p>

          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 10em; min-height: 10em;" model-init="exampleCode" class="form-control form-code left">(= pair `('dog' 'lizard'))

(console.log 'cat' ...pair)

; cat dog lizard
                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 10em; min-height: 10em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 10em; min-height: 10em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code>
          <h3 id="rest-parameter">Rest Parameter</h3><p>Prefix a parameter with <code>...</code> or <code>…</code> to make it a <em>rest parameter</em> that collects the remaining arguments into a list. This works the same way as destructuring assignment:</p>

          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 14em; min-height: 14em;" model-init="exampleCode" class="form-control form-code left">(def categorise quick ...moderate slow
  (console.log (+ '(' (moderate.join ' ') ')')))

(categorise 'hare' 'turtle' 'human' 'snail')

; (turtle human)

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 14em; min-height: 14em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 14em; min-height: 14em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code>
          <h2 id="comprehensions">Comprehensions</h2><p>Other languages typically devise special syntax for list comprehensions (a set builder notation). Jisp’s basic features serve as a limited version of list comprehension without any special notation.</p>
<p><code>range</code> is a trivial built-in function that returns a list from N to M:</p>

          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 18em; min-height: 18em;" model-init="exampleCode" class="form-control form-code left">(range 0 5)

; (0 1 2 3 4 5)

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 18em; min-height: 18em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 18em; min-height: 18em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p><code>for</code> and <code>while</code> (see <a href="#loops">Loops</a>) are list-building expressions and can be combined with <code>range</code>, and optionally <code>if</code>, to make a comprehension:</p>

          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 18em; min-height: 18em;" model-init="exampleCode" class="form-control form-code left">(for x (range 0 6) (* x x))

; (0 1 4 9 16 25 36)
                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 18em; min-height: 18em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 18em; min-height: 18em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code>
          <h2 id="conditionals">Conditionals</h2><p>Jisp improves the JavaScript conditionals and gives you some new ones. It’s also trivial to define your own conditionals with <a href="#macros">macros</a>.</p>
<pre><code>is      ; equality test
isnt    ; inequality test
not     ; negation
or      ; ||
and     ; &amp;&amp;
in      ; value in iterable
of      ; property of object
isa     ; positive type check
isnta   ; negative type check
?       ; existence check
?!      ; nonexistence check
any     ; picks first existing value, if any
if      ; if
switch  ; switch
</code></pre>
          <h3 id="logic">Logic</h3><p><code>is</code> is the equality test. With a single argument, it checks its truthiness by double negation. With two or more arguments, it checks if the first equals any of the others by a combination of <code>===</code> and <code>||</code>:</p>
<pre><code>(is &lt;name&gt;)
(is &lt;name&gt; &lt;something&gt;)
(is &lt;name&gt; &lt;something&gt; [&lt;other&gt; ...])
</code></pre>
          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 14em; min-height: 14em;" model-init="exampleCode" class="form-control form-code left">; truthiness check
(is true)

; equality
(is grass 'green')

; or-equality: true if any match
(is she 'smart' 'beautiful' 'artistic')

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 14em; min-height: 14em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 14em; min-height: 14em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p><code>isnt</code> is the inverted form of <code>is</code> which also takes multiple arguments:</p>
<pre><code>(isnt &lt;name&gt;)
(isnt &lt;name&gt; &lt;something&gt;)
(isnt &lt;name&gt; &lt;something&gt; [&lt;other&gt; ...])
</code></pre>
          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 14em; min-height: 14em;" model-init="exampleCode" class="form-control form-code left">; falsiness check (same as `not`)
(isnt false)

; inequality
(isnt fire wet)

; and-inequality: true if none match
(isnt she 'grumpy' 'magpie' 'far away')

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 14em; min-height: 14em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 14em; min-height: 14em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p>Logical or is <code>or</code> and logical and is <code>and</code>. Like many other forms, they take multiple arguments:</p>
<pre><code>(or  [&lt;a&gt; [&lt;b&gt; ...]])
(and [&lt;a&gt; [&lt;b&gt; ...]])
</code></pre>
          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 7em; min-height: 7em;" model-init="exampleCode" class="form-control form-code left">(or NaN Infinity `myvar)

(and true 'sun is hot' (&lt; 2 3))

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 7em; min-height: 7em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 7em; min-height: 7em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p>Check if a value is in an iterable (array or string) with <code>in</code>:</p>
<pre><code>(in &lt;value&gt; &lt;iterable&gt;)
</code></pre>
          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 10em; min-height: 10em;" model-init="exampleCode" class="form-control form-code left">(= bush 'woods')

(in bush `('forest' 'woods' 'thicket'))  ; true

(in 's' 'mystring')  ; true

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 10em; min-height: 10em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 10em; min-height: 10em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p>Check if an object has a property with <code>of</code>:</p>
<pre><code>(of &lt;property&gt; &lt;object&gt;)
</code></pre>
          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 12em; min-height: 12em;" model-init="exampleCode" class="form-control form-code left">(= snake (venom:  yes
          fangs:  yes
          talons: no))

(of 'venom' snake)  ; true

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 12em; min-height: 12em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 12em; min-height: 12em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p><code>isa</code> is a short way to test an object’s type. It takes multiple arguments and returns true if any match:</p>
<pre><code>(isa &lt;name&gt; &lt;type&gt; [&lt;type&gt; ...])
</code></pre>
          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 7em; min-height: 7em;" model-init="exampleCode" class="form-control form-code left">(isa Math.PI 'number')         ; true

(isa null 'number' 'boolean')  ; false

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 7em; min-height: 7em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 7em; min-height: 7em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p><code>isnta</code> is the negated version of <code>isa</code>. It takes multiple arguments and returns true if none match:</p>
<pre><code>(isnta &lt;name&gt; &lt;type&gt; [&lt;type&gt; ...])
</code></pre>
          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 7em; min-height: 7em;" model-init="exampleCode" class="form-control form-code left">(isnta null 'function')          ; true

(isnta 'Sun' 'number' 'string')  ; false

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 7em; min-height: 7em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 7em; min-height: 7em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code>
          <h3 id="existence">Existence</h3><p>Jisp provides three powerful existence macros: <code>?</code>, <code>?!</code>, and <code>any</code>.</p>
<p><code>?</code> is the ultimate existence checker. This macro takes any number of arguments and resolves to <code>true</code> if any of them exist (are defined) and to <code>false</code> otherwise.</p>
<pre><code>(? &lt;name&gt;)
(? &lt;name&gt; [&lt;name&gt; ...])
(? &lt;object.property&gt; [&lt;name&gt; ...])
</code></pre>
          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 10em; min-height: 10em;" model-init="exampleCode" class="form-control form-code left">(= elephants 'exist')

(? dinosaurs)           ; false

(? mammoths elephants)  ; true

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 10em; min-height: 10em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 10em; min-height: 10em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p>It’s smart about properties: it takes property references apart and checks them in order, starting with the base object, letting you pinpoint the existence of a property with just one conditional:</p>

          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 8em; min-height: 8em;" model-init="exampleCode" class="form-control form-code left">(? object.property[0]['method'])

; false because object not defined
; no runtime error

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 8em; min-height: 8em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 8em; min-height: 8em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p><code>?!</code> is the negated version of <code>?</code> with the exact same qualities:</p>
<pre><code>(?! &lt;name&gt;)
(?! &lt;name&gt; [&lt;name&gt; ...])
(?! &lt;object.property&gt; [&lt;name&gt; ...])
</code></pre>
          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 8em; min-height: 8em;" model-init="exampleCode" class="form-control form-code left">(?! myVar null)             ; false: null exists

(?! obj.prop[0]['method'])  ; true: not defined

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 8em; min-height: 8em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 8em; min-height: 8em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p><code>any</code> is a sliding switch that combines <code>or</code> and <code>?</code>: it resolves to the first value that exists and is truthy, or just the last value that exists:</p>
<pre><code>(any &lt;name&gt; [&lt;name&gt; ...])
</code></pre>
          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 12em; min-height: 12em;" model-init="exampleCode" class="form-control form-code left">(any NaN Infinity)

; Infinity: it's truthy

(any false 0 obj.prop[0] Math.PI)

; Math.PI

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 12em; min-height: 12em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 12em; min-height: 12em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p>Single conditional and no runtime error.</p>

          <h3 id="if">If</h3><p>Like everything in jisp, <code>if</code> is a single form that resolves to a value. When possible, it compiles into the ternary form. You can assign an <code>if</code> to a variable or return it from a function.</p>
<pre><code>(if &lt;test&gt; &lt;then&gt; [&lt;elif test then&gt; ...] &lt;else&gt;)
(if &lt;test&gt; &lt;then&gt; &lt;else&gt;)
(if &lt;test&gt; &lt;then&gt;)
</code></pre>
          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 22em; min-height: 22em;" model-init="exampleCode" class="form-control form-code left">; ternary form: single expression per branch

(if (is 'universe expanding')      ; test
    (console.log 'flight normal')  ; then-branch
    (alert 'catastrophe'))         ; else-branch

; block form: more than one expression per branch

(if hunting
    (do (= beast (randomBeast))
        (shoot beast))             ; then-branch
    (cook 'meat'))                 ; else-branch

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 22em; min-height: 22em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 22em; min-height: 22em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p>Like everything else, the block form resolves to a value that can be assigned or returned:</p>

          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 20em; min-height: 20em;" model-init="exampleCode" class="form-control form-code left">(def hashToArray form
  (if (isa form 'object')
    (over val key form
      (+ key ': ' val))))

; resolves to a value eventually returned by the function

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 20em; min-height: 20em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 20em; min-height: 20em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p>Else-ifs are special forms <em>inside</em> the <code>if</code> expression. The last non-elif expression is taken as the else-branch (undefined if omitted).</p>
<pre><code>(elif &lt;test&gt; &lt;branch&gt;)
</code></pre>
          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 14em; min-height: 14em;" model-init="exampleCode" class="form-control form-code left">(if hungry
    (eat)                   ; then-branch
    (elif thirsty (drink))
    (elif tired (sleep))
    (write code))           ; else-branch

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 14em; min-height: 14em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 14em; min-height: 14em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code>
          <h3 id="switch">Switch</h3><p>A <code>switch</code> form automatically inserts <code>break;</code> statements, protecting you from accidental fall-through:</p>
<pre><code>(switch &lt;predicate&gt; [&lt;case test body&gt; ...] &lt;default&gt;)
</code></pre>
          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 16em; min-height: 16em;" model-init="exampleCode" class="form-control form-code left">(switch x
  (case -1 'negative one')
  (case 0  'zero-ish')
  NaN)

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 16em; min-height: 16em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 16em; min-height: 16em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p>Quite naturally, <code>switch</code> is also an expression that resolves to a value:</p>

          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 20em; min-height: 20em;" model-init="exampleCode" class="form-control form-code left">(console.log (switch Math.PI
  (case 1 'welcome to Lineland')
  (case 2 'welcome to Flatland')
  (case 3 'welcome to ancient Egypt')
  'world still spinning'))

; world still spinning

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 20em; min-height: 20em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 20em; min-height: 20em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p>More conditionals coming up. The <a href="#macros">macro</a> system also makes it trivial to define your own conditionals with arbitrary syntax.</p>

          <h2 id="loops">Loops</h2><p>Jisp abstracts away the legacy details of JavaScript loops and makes them expressive. It comes with three loops: <code>for</code>, <code>over</code>, and <code>while</code>.</p>

          <h3 id="over">Over</h3><p>The <code>over</code> loop iterates over values and keys of any object. It also accesses inherited properties and custom prototype methods.</p>
<pre><code>(over [&lt;value&gt; [&lt;key&gt;]] &lt;iterable&gt; &lt;body&gt;)
</code></pre>
          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 16em; min-height: 16em;" model-init="exampleCode" class="form-control form-code left">(= animals (squirrel: 'Eevee' fox: 'Vulpix'))

(over val key animals (console.log key val))

''
; squirrel Eevee
; fox Vulpix

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 16em; min-height: 16em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 16em; min-height: 16em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p><code>over</code> automatically builds a list of values from each iteration. This list is its resolved value:</p>

          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 18em; min-height: 18em;" model-init="exampleCode" class="form-control form-code left">(= cats (pink: 'Persian' yellow: 'Skitty'))

(= catnames
   (over name cats name))

; ('Persian' 'Skitty')

(= bigcolours
   (over name colour cats (colour.toUpperCase)))

; ('PINK' 'YELLOW')

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 18em; min-height: 18em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 18em; min-height: 18em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code>
          <h3 id="for">For</h3><p>When iterating over arrays and strings, you usually want to hit all elements in order and don’t want extra properties tagging along. In those cases, use the <code>for</code> loop:</p>
<pre><code>(for [&lt;value&gt; [&lt;index&gt;]] &lt;iterable&gt; &lt;body&gt;)
</code></pre>
          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 12em; min-height: 12em;" model-init="exampleCode" class="form-control form-code left">(for char index 'meow'
  (console.log index char))

''
; 0 m
; 1 e
; 2 o
; 3 w

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 12em; min-height: 12em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 12em; min-height: 12em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p>It resolves to a list of values from each iteration, if asked nicely:</p>

          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 14em; min-height: 14em;" model-init="exampleCode" class="form-control form-code left">(for char index 'winter'
     (+ index ': ' char))

; ('0: w' '1: i' '2: n' '3: t' '4: e' '5: r')

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 14em; min-height: 14em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 14em; min-height: 14em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p><strong>[NYI]</strong>: planned feature. If the iterable is an integer larger than 0, jisp will substitute it for a range starting at 1, making for a repeat-N loop:</p>
<pre><code>(= warcry &#39;&#39;)
(for 5 (+= warcry &#39;waagh! &#39;))
warcry
; waagh! waagh! waagh! waagh! waagh!
</code></pre>
          <h3 id="while">While</h3><p>For finer-grained control, use the <code>while</code> loop. It works like in JavaScript, but like everything in jisp, it’s an expression. By default, it resolves to a list of values from each iteration:</p>
<pre><code>(while &lt;test&gt; &lt;body&gt;)
</code></pre>
          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 14em; min-height: 14em;" model-init="exampleCode" class="form-control form-code left">(= bugs `('missing comma' 'missing semicolon'))

(while (&gt; bugs.length 0)
       (+ (bugs.shift) ' avoided'))

; ('missing comma avoided'
;  'missing semicolon avoided')

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 14em; min-height: 14em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 14em; min-height: 14em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p>You can also order a final resolved value:</p>
<pre><code>(while &lt;test&gt; &lt;body&gt; &lt;return-value&gt;)
</code></pre>
          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 18em; min-height: 18em;" model-init="exampleCode" class="form-control form-code left">(= beers 0)
(def sober (&lt; beers 10))

(= drunk (while (sober)
                (++ beers)
                (+ 'drunk after ' beers ' beers')))

; drunk after 10 beers

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 18em; min-height: 18em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 18em; min-height: 18em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code>
          <h2 id="macros">Macros</h2><p>Macros are compile-time functions that generate code. A macro takes code as input and returns code that’s put in its place. At compile, macro definitions are yanked from your code, then macros are recursively expanded. After all macros are expanded, jisp is compiled to JS:</p>
<pre><code>Definition:
(mac name [&lt;params&gt;] &lt;body&gt;)

Call:
(&lt;name&gt; [&lt;code&gt;])
</code></pre>
          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 14em; min-height: 14em;" model-init="exampleCode" class="form-control form-code left">(mac firstDefinedTruthy ...values
  `(or ,...(for value values
    `(and (? ,value) ,value))))

(firstDefinedTruthy NaN Infinity myVar)

; add your own macro call here

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 14em; min-height: 14em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 14em; min-height: 14em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p>Most of <code>jisp.jisp</code> is written with macros.</p>
<p>The lifetime of your code without macros:</p>
<pre><code>code -&gt; compile into JS -&gt; execute
</code></pre><p>The lifetime with macros:</p>
<pre><code>code =&gt; parse macros &lt;-&gt; expand macros -&gt; compile into JS =&gt; execute
</code></pre><p>It seems to be a trend among modern languages to introduce limited macro support in form of templates. Jisp brings macros to JavaScript but it’s <strong>not</strong> limited to templating. Macros are complete, real, custom functions using the full power of the language to run arbitrary logic and transform code in arbitrary ways.</p>

          <h3 id="templating">Templating</h3><p>Templating is the most basic use. Let’s make a macro that generates named function definitions:</p>
<pre><code>Prefix code to return with `:
`(&lt;code&gt;)

Unquote elements with , to resolve (transclude) them during macro call:
`(&lt;code&gt; ,&lt;elem&gt; &lt;code&gt;)
</code></pre>
          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 28em; min-height: 28em;" model-init="exampleCode" class="form-control form-code left">; yanked at macro parse
(mac makeReduce name operator
  `(def ,name ...args
    (if (isnt args.length 0)
        (args.reduce {,operator #0 #1}))))

; yanked at macroexpand
(makeReduce mul *)

; code put back at macroexpand
; (def mul ...args
;   (if (isnt args.length 0)
;     (args.reduce {* #0 #1})))

; add your own macro call here
; try a non-operator

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 28em; min-height: 28em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 28em; min-height: 28em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p>In this example, the macro returns the form starting with <code>def</code>. Quoting with <code>` </code> prevents this form from resolving during the macro call and lets the macro return it as code. Unquoting the macro arguments <code>name</code> and <code>operator</code> by prepending them with <code>,</code> transcludes them into the template. Try adding your own macro calls to generate new definitions.</p>
<p>Because macros are real functions, you can edit the return code in arbitrary ways. For instance, based on the arguments passed. Let’s make our operator macro slightly more versatile:</p>

          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 30em; min-height: 30em;" model-init="exampleCode" class="form-control form-code left">(mac makeReduce name operator zeroValue
  `(def ,name ...args (do
    ; included if zeroValue was passed
    ,(if (? zeroValue)
      `(args.unshift ,zeroValue))
    ; included always
    (if (is args.length 0)
      ,zeroValue  ; defaults to undefined
      (args.reduce {,operator #0 #1})))))

(makeReduce add +)

(makeReduce div / 1)

; try your own macro call

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 30em; min-height: 30em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 30em; min-height: 30em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p>In this example, the logic <code>(args.unshift ,zeroValue)</code> is only included if a <code>zeroValue</code> was passed to the macro. Run the resulting functions with none and one argument to see the difference.</p>

          <h3 id="code-construction">Code Construction</h3><p>Because jisp code is a series of nested arrays, macros can deconstruct and construct it on the fly. This is why we have those parentheses.</p>
<p>As a silly example, you could enable reverse syntax by reversing the code passed to a macro:</p>

          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 24em; min-height: 24em;" model-init="exampleCode" class="form-control form-code left">(mac reverse form (do
  (def rev form
     (if (Array.isArray form)
         (do (for f form
               (rev f))
             (.reverse))
         form))
  (rev form)))

(reverse
  (('world' 'hello ' (() quote) +) console.log))

; try your own reverse code

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 24em; min-height: 24em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 24em; min-height: 24em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p>But let’s get more serious. Getting back to the example at the top of the page. Suppose you’re writing a gulp config file full of repetitive blocks like these:</p>
<pre><code>gulp.task(&#39;jisp&#39;, function() {
  return handle(gulp.src(jispFiles))
  .pipe(handle(concat(&#39;app.js&#39;)))
  .pipe(handle(jisp()))
  .pipe(handle(uglify({mangle: false})))
  .pipe(handle(gulp.dest(&#39;public/js/tmp/&#39;)));
});
</code></pre><p>You can’t deduplicate this with functional abstractions alone, and are forced to write this repetitive code by hand. But you can abstract it away with a macro:</p>

          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 30em; min-height: 30em;" model-init="exampleCode" class="form-control form-code left">(mac task name ...args (do
  (= pipeline `(do (handle (,(args.shift)
                            ,(args.shift)))))
  (while (&gt; args.length 0) (do
    (= left  (args.shift)
       right (args.shift))
    (pipeline.push `(.pipe (handle (,left ,right))))))
  `(gulp.task ,name (fn ,pipeline))))

; call it like so:

(task       'jisp'
  gulp.src  jispFiles
  conc      'app.js'
  jisp      ()
  uglify    (mangle: no)
  gulp.dest 'public/js/tmp/')

; try adding your own task

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 30em; min-height: 30em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 30em; min-height: 30em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p>What happened? The macro takes its arguments as an array, takes it apart in pairs, and constructs a new array of the resulting code, filling in the repetitive blocks we wanted to dedup. The constructed code in this example is:</p>
<pre><code>(gulp.task &#39;jisp&#39; (fn (do
  (handle (gulp.src jispFiles))
  (.pipe (handle (conc &#39;app.js&#39;)))
  (.pipe (handle (jisp)))
  (.pipe (handle (uglify (mangle: no))))
  (.pipe (handle (gulp.dest &#39;public/js/tmp/&#39;))))))
</code></pre><p>And it replaces the macro call before the code is compiled.</p>
<p>We’ve just enabled a new shorter, cleaner syntax for the rest of our configuration file, and deduplicated our code in a way not possible with plain JavaScript. It should be noted that macros take any kind of input; it could be hash tables or bigger blocks of code. See <code>jisp.jisp</code> for bigger examples.</p>

          <h3 id="macro-import-export">Macro Import and Export</h3><p>Macros can be imported in three ways:</p>
<ul>
<li>compile or <code>require</code> a macro-containing file before others within the same Node runtime;</li>
<li>use the <code>importMacros</code> method of the object exported by the compiler;</li>
<li>access the <code>macros</code> store exported by the compiler.</li>
</ul>
<p>Macros are kept in the <code>macros</code> object that exists during the compiler runtime. It’s exposed in the <code>jisp</code> object and can be accessed and modified directly. The recommended way to import macros is by calling the <code>importMacros</code> method that takes one or more macro stores and merges them into the macro object, overriding the existing macros. Each store is a hash table where keys are macro names and values are macro functions.</p>
<pre><code>(= myStore (testMacro: (fn `nameToReturn)))
(= jisp (require &#39;jisp&#39;))
(jisp.importMacros myStore)
(testMacro)  ; replaced by `nameToReturn`
</code></pre><p>The <code>macros</code> object persists between compiler calls. If you’re using a build script that compiles multiple jisp files within the same runtime, you can simply put macros in a file and require or compile it before others. This also works when running jisp scripts directly with <code>require</code>.</p>
<p>When a macro is referenced in code, it’s embedded at the top of your program and can be assigned and exported from a module. See <code>macros.jisp</code> for an example.</p>

          <h3 id="macro-notes">Notes</h3><p>After each macro expansion, the new code is recursively checked for macro definitions and calls. This allows macros to be nested, and even contain new macro definitions. See <code>jisp.jisp</code> for examples; most of it is written with nested macros.</p>
<p>To avoid confusing macros for functions, it’s good style to begin their names with <code>mac</code>.</p>
<p>It’s important to realise that macros are compile-time, not run-time. They live in the land of names, not in the land of values like functions. Rather than passing values by names to macros, you pass <em>names</em>, or code in general. A macro doesn’t give a flying duck about scope or variable bindings. You aren’t constrained by scope or object reference issues, and don’t have to pass around objects you want to access. You just construct the code you want, where you want it, at compile time.</p>

          <h2 id="built-ins">Built-ins and Embedding</h2><p>Jisp comes with some built-in macros and functions, and faculties for importing them and embedding into compiled programs.</p>

          <h3 id="built-in-macros">Macros</h3><p>Most built-in macros are conditionals. See the <a href="#conditionals">conditionals</a> section. Some are property accessors.</p>

          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 22em; min-height: 22em;" model-init="exampleCode" class="form-control form-code left">(car  x)
(head x)
(cdr  x)
(tail x)
(init x)
(last x)
(let  x 10 (* x 2))
(isa  x 'type')
(isnt x 'type')
(?    x)
(?!   x)
(any  x y)

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 22em; min-height: 22em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 22em; min-height: 22em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code>
          <h3 id="built-in-functions">Functions</h3><p>Jisp has a special faculty for adding global functions to the language. If any of them is referenced in code, it’s embedded at the top of your program on compile. No globals are leaked. If the function is reassigned before being referenced, it’s not embedded. Like with macros, jisp provides a way to import these functions, extending the language. It also comes with a few:</p>
<p><code>list</code> is a list (array) builder. It’s roughly equivalent to <code>(Array x)</code>, but also accepts 0 or 1 arguments.</p>
<pre><code>(list [&lt;args&gt; ...])
</code></pre>
          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 12em; min-height: 12em;" model-init="exampleCode" class="form-control form-code left">(list)

; ()

(list 'wizard' 'hat' 'staff')

; ('wizard' 'hat' 'staff')

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 12em; min-height: 12em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 12em; min-height: 12em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p><code>concat</code> is like <code>list</code> except it flattens lists passed as arguments, concatenating them:</p>
<pre><code>(concat [&lt;args&gt; ...])
</code></pre>
          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 16em; min-height: 16em;" model-init="exampleCode" class="form-control form-code left">(concat `(yes no) `(NaN) Infinity)

; (yes no NaN Infinity)

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 16em; min-height: 16em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 16em; min-height: 16em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code><p><code>range</code> is a function that builds a list from N to M. It’s used in comprehensions:</p>
<pre><code>(range [start] end)  ; default start 0
</code></pre>
          <isolated-code>
            <div class="row">
              <div class="col-md-6 col-code left">
                <textarea type="text" style="height: 16em; min-height: 16em;" model-init="exampleCode" class="form-control form-code left">(range -1 6)

; (-1 0 1 2 3 4 5 6)

                </textarea>
              </div>
              <div class="col-md-6 col-code right">
                <pre style="height: 16em; min-height: 16em;" ng-show="!showJSOutput" class="form-code right">{{compiledCode}}</pre>
                <button role="button" ng-click="evalJS()" ng-show="!showJSOutput" class="btn btn-sm btn-default button-eval">eval</button>
                <pre style="height: 16em; min-height: 16em;" ng-show="showJSOutput" class="form-code right output">{{evalJSOutput}}</pre>
                <button role="button" ng-click="showJSOutput = false" ng-show="showJSOutput" class="btn btn-sm btn-warning button-eval">close</button>
              </div>
            </div>
          </isolated-code>
          <h3 id="function-import-export">Function Import and Export</h3><p>Similarly to macros, functions can be imported in two ways:</p>
<ul>
<li>use the <code>importFunctions</code> method of the module object;</li>
<li>directly access and modify the function store exposed by the module.</li>
</ul>
<p>The global functions are stored in the <code>functions</code> object that exists during the compiler runtime. Unlike macros, compiling a file doesn’t affect the function store. You need to import them like so:</p>
<pre><code>(= myFuncs (sqr:  (fn x (* x x))
            cube: (def cube x (* x x x))))

(= jisp (require &#39;jisp&#39;))

(jisp.importFunctions myFuncs)

sqr      ; function embed
(cube 3) ; function embed, 27
</code></pre><p>Try this in a REPL or a file to see how functions are embedded after importing. This faculty makes it easy to extend the language in a modular way with zero global leaks and zero global dependency.</p>

          <h2 id="style">Style</h2><p>Jisp is insensitive to whitespace, but humans don’t read code by counting parens; we read it by indentation. Your indentation should reflect the nesting of expressions, branches of execution. Parallel branches share the same indent, nested branches are indented further.</p>
<pre><code>; BAD, misleading about nesting
(def plusname name
     (if (isNaN (Number (last name)))
     (+ name 0)
     (+ (init name) (+ 1 (Number (last name))))))

; GOOD, reflects branching properly
(def plusname name
     (if (isNaN (Number (last name)))
         (+ name 0)
         (+ (init name) (+ 1 (Number (last name))))))
</code></pre><p>When nesting isn’t deep, try lining up each next indent with the second word on the preceding line (example above). Otherwise, stick with two spaces for each new level.</p>

          <h2 id="known-bugs">Known Bugs and NYI</h2><p>I’ll be gradually moving this to the <a href="https://github.com/Mitranim/jisp/issues">git issues</a>. You can help by opening new issues.</p>
<p>Syntax (tokeniser and lexer limitations):</p>
<ul>
<li>[NYI] <code>.dot</code> and <code>[bracket]</code> notation can’t be used with primitive literals and lists, using <code>(get object property)</code> and <code>do</code> notation for now.</li>
<li><code>#n</code> notation can’t be used with <code>` </code> <code>...</code> <code>.dot</code> and <code>[bracket]</code> notation, using <code>get</code> and <code>do</code> for now.</li>
<li>Regex literals are mangled when passed as an argument to a function.</li>
<li>Whitespace in regexes bugs out the tokeniser regexes.</li>
<li>Tokeniser can’t handle more than one backslash immediately preceding a quote.</li>
<li>Tokeniser fails to split <code>&quot;}&quot;}</code>.</li>
<li>Tokeniser sometimes fails to split <code>[</code> <code>]</code> from other things (example: <code>form[</code> in <code>form[,i]</code>).</li>
<li>[NYI] Identifier names (variables etc) can’t include non-ASCII letters.</li>
</ul>
<p>REPL:</p>
<ul>
<li>Multiline input counts parentheses inside strings and regexes.</li>
</ul>
<p>Operator-functions like <code>+</code>:</p>
<ul>
<li>[NYI] Spread not implemented.</li>
<li>[NYI] Can’t be passed around by name.</li>
<li>[NYI] More of them need to support multiple arguments.</li>
</ul>
<p>Macros quirks:</p>
<ul>
<li>Macros break when they contain strings with quotes inside them (probably the tokeniser).</li>
<li>Dot and bracket notation on regexes renders as <code>[native code]</code>, use the <code>get</code> and <code>do</code> notation for now.</li>
<li>In quoted lists in macros, internal quoted lists have to be double-quoted. Todo comprehend and fix.</li>
<li>(Not sure if bug, todo review.) When passing a non-quoted list to a macro, it’s spread out instead of being passed as a list. (Got fixed? ToDo check.)</li>
</ul>
<p>The parser (?) appends an extra <code>undefined</code> to the end of the file if the last line is a comment (got fixed? need to check).</p>
<p>When using conditionals (e.g. <code>and</code>) with forms that compile to multiple lines, all but last line will be put before the conditional, executing regardless of which of the tests are passed.</p>
<p>Hoisting of multi-line statements above their place in code can sometimes cause actions to be executed out of order. Example: a logical conditional like <code>and</code> consisting of block expressions like <code>try</code>.</p>
<p>[NYI] <code>command</code> doesn’t automatically load the <code>register</code> module.</p>
<p>Macro embedding-hoisting doesn’t respect global scope, overwrites previously defined names. Not sure what to do about this; it might be a good thing, considering that macros are core to the language.</p>

          <h2 id="why">Why Use Jisp</h2><p>Generally, you should read this documentation to get an idea of the possibilities opened by jisp. Here’s a super short gist.</p>
<h4 id="simple-and-safe">Simple and Safe</h4>
<p>Despite being more powerful, jisp is a lot simpler than JavaScript. Is has practically no syntax; there’s no semicolons, commas, or linebreaks to trip yourself over, no special rules for keywords and operators. Everything uses the same rules, making it hard to make an error.</p>
<p>It also absracts away legacy implementation details like <code>var</code>, <code>break</code> and the primitive <code>for</code> loop, eliminating entire classes of easy to make and hard to spot errors.</p>
<h4 id="powerful">Powerful</h4>
<p>At its heart, jisp is just JavaScript. But it’s also much more.</p>
<p>On the surface level, it builds some coding patterns right into the language and provides powerful higher-level conditionals and loops, making your programs terser. Its expressive functional syntax and implicit value resolution lets you focus on your ideas and have the language take care of data returns.</p>
<p>More importantly, it lets you define syntactic abstractions and automatically generate code, reprogram and extend the language, implement embedded domain-specific languages on top of JS, deduplicate code in ways impossible with plain JavaScript.</p>

          <h3 id="why-over">Why Jisp Over [insert dialect X]</h3><p>There’s a bunch of Lisp-JavaScript dialects floating in the wild. So why jisp?</p>
<h4 id="javascript-first">JavaScript-first</h4>
<p>Most other Lisp-JavaScript implementations are attempts to port a [language X] to JavaScript. In best cases, they carry legacy design details that don’t make sense in the JavaScript environment or obfuscate the code (example: artificial distinction between arrays and code in most dialects). In worse cases, they clog the runtime with a reimplementation of another language on top of JavaScript.</p>
<p>Jisp is JS-native and axiomatic. Is has no needless concepts, no legacy syntax, and no runtime cost. Jisp focuses on the core ideas of code-as-data, S-expressions, macros, and brings them to JavaScript, introducing as few new concepts as possible. Everything else is left looking familiar and fits intuitively within the new syntax.</p>
<p>It also carefully abstracts away legacy JavaScript pitfalls, making the language safer without introducing alien concepts as a cost.</p>
<p>Jisp doesn’t target an [insert language X] programmer. It targets the JavaScript programmer.</p>
<h4 id="featureful">Featureful</h4>
<p>Jisp is full of features of immediate, practical use to a JavaScript developer. It’s not different for difference sake: it enables a whole new level of abstraction and makes full use of it, coming prepackaged with powerful tools. It takes practical features from other modern languages and the future of JavaScript and gives them to you now. Built-in macros and functions, shortcuts to common patterns, import and embedding for macros and global functions, spreading, destructuring, and more.</p>
<h4 id="axiomatic">Axiomatic</h4>
<p>Despite aiming for features, jisp takes the minimalistic, simplest possible approach to design. It wants you to type less and do more with less code. It doesn’t try to imitate [language X] — or JavaScript, for that matter. It aims to be succinct and get out of your way.</p>

          <h2 id="todo-upcoming">ToDo Upcoming</h2><p>Working on these.</p>
<ul>
<li>Fix the known bugs and NYI.</li>
<li>More built-in macros.</li>
<li>Embedding of operator-functions to allow passing them around by name (e.g. <code>(arr.sort &gt;)</code>).</li>
<li>Compiler error messages for when special forms like <code>=</code> and <code>quote</code>, as well as JS keywords, are met outside their destined place (first element in list).</li>
<li>Lexer or parser error messages for common but hard to spot errors like infix <code>+</code>.</li>
<li>Polyfill for older engines.</li>
</ul>

          <h2 id="todo-wishlist">ToDo Wishlist</h2><p>These will take me a while. Get hacking and contribute!</p>
<p>Bigger:</p>
<ul>
<li>A test suite.</li>
<li>Source map support.</li>
<li>Syntax highlighting for HTML and language modules for code editors (Sublime Text, Atom).</li>
<li>Some way of generating guaranteed unique variable names in macros (like <code>gensym</code>). Not sure if necessary.</li>
<li>Compiler option to only macroexpand and print out expanded jisp code (needs a jisp beautifier).</li>
</ul>
<p>Smaller:</p>
<ul>
<li>Prettier JS output (fewer parens etc.).</li>
<li>Distinguish between <code>;</code> <code>;;</code> and <code>;;;</code> comments. <code>;;</code> should quote the next form in parentheses, ignoring end-of-line. <code>;;;</code> should be a multiline block comment.</li>
<li>Auto-reindent plugins for code editors (Sublime Text, Atom).</li>
<li>Support for multiple expressions in <code>elif</code> tests when possible (comma-separated).</li>
<li>Support for multiple tests in <code>switch</code>/<code>case</code>.</li>
<li>Multiline regexes.</li>
<li>REPL non-verbose option.</li>
<li>REPL history.</li>
</ul>

          <h2 id="acknowledgements">Acknowledgements</h2><p>Jisp is massively inspired by <a href="http://coffeescript.org">CoffeeScript</a> and uses bits of its source for CLI utils. Design inspiration from <a href="http://paulgraham.com/arc.html">Arc</a> and the Lisp family of languages, bits from other places. General inspiration from <a href="https://github.com/smihica/arc-js">Arc-js</a>.</p>
<p>Copyright (c) 2014 Mitranim, under the MIT License.</p>

        </div>
        <div class="col-lg-3">
          <div role="complementary" bs-affix bs-scrollspy-list class="bs-sidebar hidden-print">
            <ul class="nav bs-sidenav">
              <li data-target="#installation"><a href="#installation">Installation and Usage</a></li>
              <li data-target="#code-structure"><a href="#code-structure">Code Structure</a></li>
              <li data-target="#everything-exp"><a href="#everything-exp">Everything an Expression</a></li>
              <li data-target="#quoting"><a href="#quoting">Quoting</a></li>
              <li data-target="#blocks"><a href="#blocks">Blocks and Chaining</a></li>
              <li data-target="#object-props"><a href="#object-props">Object Properties</a></li>
              <li data-target="#functions"><a href="#functions">Functions
                  <ul class="nav">
                    <li data-target="#definition"><a href="#definition">Definition</a></li>
                    <li data-target="#call-return"><a href="#call-return">Calling and Returning</a></li>
                    <li data-target="#lambda"><a href="#lambda">Lambda Syntax</a></li>
                    <li data-target="#let"><a href="#let">Let</a></li>
                  </ul></a></li>
              <li data-target="#assignment"><a href="#assignment">Assignment</a></li>
              <li data-target="#destructuring"><a href="#destructuring">Destructuring Assignment</a></li>
              <li data-target="#spreading-rest"><a href="#spreading-rest">Spreading and Rest Parameter
                  <ul class="nav">
                    <li data-target="#spread-into-list"><a href="#spread-into-list">Spread Into List</a></li>
                    <li data-target="#argument-spread"><a href="#argument-spread">Argument Spread</a></li>
                    <li data-target="#rest-parameter"><a href="#rest-parameter">Rest Parameter</a></li>
                  </ul></a></li>
              <li data-target="#comprehensions"><a href="#comprehensions">Comprehensions</a></li>
              <li data-target="#conditionals"><a href="#conditionals">Conditionals
                  <ul class="nav">
                    <li data-target="#logic"><a href="#logic">Logic</a></li>
                    <li data-target="#existence"><a href="#existence">Existence</a></li>
                    <li data-target="#if"><a href="#if">If</a></li>
                    <li data-target="#switch"><a href="#switch">Switch</a></li>
                  </ul></a></li>
              <li data-target="#loops"><a href="#loops">Loops
                  <ul class="nav">
                    <li data-target="#over"><a href="#over">Over</a></li>
                    <li data-target="#for"><a href="#for">For</a></li>
                    <li data-target="#while"><a href="#while">While</a></li>
                  </ul></a></li>
              <li data-target="#macros"><a href="#macros">Macros
                  <ul class="nav">
                    <li data-target="#templating"><a href="#templating">Templating</a></li>
                    <li data-target="#code-construction"><a href="#code-construction">Code Construction</a></li>
                    <li data-target="#macro-import-export"><a href="#macro-import-export">Macro Import and Export</a></li>
                    <li data-target="#macro-notes"><a href="#macro-notes">Notes</a></li>
                  </ul></a></li>
              <li data-target="#built-ins"><a href="#built-ins">Built-ins and Embedding
                  <ul class="nav">
                    <li data-target="#built-in-macros"><a href="#built-in-macros">Macros</a></li>
                    <li data-target="#built-in-functions"><a href="#built-in-functions">Functions</a></li>
                    <li data-target="#function-import-export"><a href="#function-import-export">Function Import and Export</a></li>
                  </ul></a></li>
              <li data-target="#style"><a href="#style">Style</a></li>
              <li data-target="#known-bugs"><a href="#known-bugs">Known Bugs and NYI</a></li>
              <li data-target="#why"><a href="#why">Why Use Jisp
                  <ul class="nav">
                    <li data-target="#why-over"><a href="#why-over">Why Jisp Over [insert dialect X]</a></li>
                  </ul></a></li>
              <li data-target="#todo-upcoming"><a href="#todo-upcoming">ToDo Upcoming</a></li>
              <li data-target="#todo-wishlist"><a href="#todo-wishlist">ToDo Wishlist</a></li>
              <li data-target="#acknowledgements"><a href="#acknowledgements">Acknowledgements</a></li>
              <li><a ng-click="gotoTop()">Top</a></li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </body>
</html>