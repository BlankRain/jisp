; Converts string tokens into native JS objects
; Desugars syntax shortcuts:
  ; quote
  ; unquote
  ; spread
  ; get (.dot and ["bracket"] notation)
; Throws syntax errors

(= util            (require "./util")
   pr              util.pr
   isList          util.isList
   isAtom          util.isAtom
   isAtomString    util.isAtomString
   isNum           util.isNum
   isRegex         util.isRegex
   isIdentifier    util.isIdentifier
   isString        util.isString
   isKey           util.isKey
   isDotName       util.isDotName
   isBracketName   util.isBracketName
   isBracketString util.isBracketString
   isPropSyntax    util.isPropSyntax)

(= module.exports lex)

(def maketest condition
     (if (is (typeof condition) "function")
         (fn tokens (condition tokens[0]))
         (elif (isRegex condition)
               (fn tokens (condition.test tokens[0])))
         (elif (isAtom condition)
               (fn tokens (is tokens[0] condition)))
         (elif (isList condition)  ; assume list of tests
               (fn tokens
                   (if (for cond i condition
                            (if (not ((maketest cond) (tokens.slice i)))
                                (return false)))
                       true)))
         (throw (Error (+ "can't test against " (pr condition))))))

(def demand tokens ...args
; lexes by the met condition and throws an error if none are met
     (do (= conditions `()
            modes      `())
         (while (> args.length 0)
                (do (= condition (args.shift)
                       mode      (args.shift))
                    (conditions.push condition)
                    (modes.push mode)
                    (= test (maketest condition))
                    (if (test tokens) (return (lex tokens mode)))))
         (throw (Error (+ "unexpected " (pr tokens[0]) " in possible modes: " (modes.join " | ") "\nTested against: " (conditions.join "   ") "\nTokens: " (pr (tokens.slice 0 10)) " ...")))))

(def expect tokens ...args
; lexes by the met condition and returns undefined if none are met
     (while (> args.length 0)
            (do (= condition (args.shift)
                   mode      (args.shift))
                (= test (maketest condition))
                (if (test tokens) (return (lex tokens mode))))
            undefined))

(def forbid tokens ...args
; throws an error if one of the conditions is met
  (for condition args
       (if ((maketest condition) tokens)
           (throw (Error (+ "unexpected " (pr tokens[0])))))))

(def addProperties tokens lexed
  (do (while (is tokens[0] "[")
             (= lexed `("get" ,lexed ,(lex tokens "property"))))
      lexed))

(def lex tokens (mode "default")
  (switch mode
    (case "default"  ; should only happen once
      (while (> tokens.length 0)
        (demand tokens
          `("("  ":"  ")") "emptyhash"
          `("(" isKey ":") "hash"
          "("              "list"
          "`"              "quote"
          ","              "unquote"
          "..."            "spread"
          "…"              "spread"
          isAtomString     "atom"
          undefined        "drop")))
    (case "list"
      (do (demand tokens "(" "drop")
          (= lexed `())
          (if (= prop (expect tokens
                "["          "property"
                isPropSyntax "property"))
              (lexed.push `("get" prop)))
          (while (isnt tokens[0] ")")  ; EOF will be caught by demand
            (lexed.push
              (demand tokens
                `("("  ":"  ")") "emptyhash"
                `("(" isKey ":") "hash"
                "("              "list"
                "`"              "quote"
                ","              "unquote"
                "..."            "spread"
                "…"              "spread"
                isAtomString     "atom")))
          (demand tokens ")" "drop")
          (addProperties tokens lexed)))
    (case "emptyhash"
      (do (demand tokens "(" "drop")
          (demand tokens ":" "drop")
          (demand tokens ")" "drop")
          (addProperties tokens (:))))
    (case "hash"
      (do (= lexed (:))
          (demand tokens "(" "drop")
          (while (isnt tokens[0] ")")  ; EOF will be caught by demand
            (do (= key  (demand tokens isKey "key"))
                (demand tokens ":" "drop")
                (= prop (demand tokens
                  `("("  ":"  ")") "emptyhash"
                  `("(" isKey ":") "hash"
                  "("              "list"
                  "`"              "quote"
                  ","              "unquote"
                  isAtomString     "atom"))
                (= lexed[key] prop)))
          (demand tokens ")" "drop")
          (addProperties tokens lexed)))
    (case "property"
      (if (isDotName tokens[0])
          ((get (demand tokens isDotName "drop") slice) 1)
          (elif (or (isBracketName tokens[0])
                    (isBracketString tokens[0]))
                (demand tokens
                  isBracketName   "drop"
                  isBracketString "drop"))
          (do (demand tokens "[" "drop")
              (= prop (demand tokens
                "("          "list"
                ","          "quote"
                isIdentifier "atom"
                isNum        "atom"
                isString     "atom"))
              (demand tokens "]" "drop")
              prop)))
    (case "quote"
      (do (demand tokens "`" "drop")
          (= lexed `("quote" ,(demand tokens
            `("("  ":"  ")") "emptyhash"
            `("(" isKey ":") "hash"
            "("              "list"
            "`"              "quote"
            ","              "unquote"
            isAtomString     "atom"))))
          (addProperties tokens lexed))
    (case "unquote"
      (do (demand tokens "," "drop")
          `("unquote" ,(addProperties tokens (demand tokens
            "("          "list"
            "`"          "quote"
            "..."        "spread"
            "…"          "spread"
            isIdentifier "atom")))))
    (case "spread"
      (do (demand tokens
            "..." "drop"
            "…"   "drop")
          `("spread" ,(addProperties tokens (demand tokens
            "("          "list"
            "`"          "quote"
            isIdentifier "atom")))))
    (case "key"
      (do (= key (demand tokens isKey "drop"))
          (forbid "[" isPropSyntax)
          key))
    (case "atom"
      (addProperties tokens (demand tokens isAtomString "drop")))
    (case "drop" (tokens.shift))
    (throw (Error (+ "unspecified lex mode: " mode)))))
