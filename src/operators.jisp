; Import
(= util         (require "./util")
   pr           util.pr
   spr          util.spr
   render       util.render
   isIdentifier util.isIdentifier
   assertForm   util.assertForm)

(def makeop op (zv undefined) (min 0) (max Infinity) (drop no)
; <operator> <zero value> <min args> <max args>
     (fn args
         (if (assertForm args min max)
             (if (is args.length 0)
                 `(,(pr zv))
                 (elif (and (is args.length 1) (? zv))
                       `(,(+ "(" zv op (spr args) ")")))
                 (elif (and (is args.length 1) drop)
                       `(,(spr args)))
                 (elif (is args.length 1)
                       `(,(+ op (spr args))))
                 (do (for arg i args (= args[i] (pr arg)))
                     `(,(+ "(" (args.join (+ " " op " ")) ")")))))))

(def makesing op
     (fn args
         (if (assertForm args 1 1)
             `(,(+ "(" op " " (spr args) ")")))))

(def reserved word (throw (Error (+ "keyword " word " is reserved"))))

(def makestate op (min 0) (max Infinity)
; For 'pure statement' keywords that give an error when trying to assign
     (fn args
         (if (assertForm args min max)
             `(,(+ op " " (spr args)) "undefined"))))

(= operators (
; Replacing jisp functions with JS operators and keywords
; ToDo infinite arguments where possible
  ; (not a b c)  ->  (and (not a) (not b) (not c))

  ; arithmetic
  "++": (fn args
    (if (assertForm args 1 1)
        (if (not (isIdentifier args[0]))
            (throw (Error "expecting identifier, got " (pr args[0])))
        `(,(+ "++" (pr args[0]))))))
  "--": (fn args
    (if (assertForm args 1 1)
        (if (not (isIdentifier args[0]))
            (throw (Error "expecting identifier, got " (pr args[0])))
            `(,(+ "--" (pr args[0]))))))
  ; logical
  "is": (fn args
    (if (is args.length 0)
        `(true)
        (elif (is args.length 1)
              `(,(+ "!!" (pr args[0]))))
        (do (= subj (args.shift))
            `(,(+ "("
                  ((get (for arg args (+ "(" (pr subj) " === " (pr arg) ")")) join) " || ")
                  ")")))))
  "isnt": (fn args
    (if (is args.length 0)
        `(false)
        (elif (is args.length 1)
              `(,(+ "!" (pr args[0]))))
        (do (= subj (args.shift))
            `(,(+ "("
                  ((get (for arg args (+ "(" (pr subj) " !== " (pr arg) ")")) join) " && ")
                  ")")))))
  "or":  (makeop "||" false)    ; single arg returns itself
  "and": (makeop "&&" true)     ; single arg returns itself
  ; Function version:
  ; "exists": (fn args            ; todo multiple args
  ;   (if (assertForm args 1 1)
  ;       `(,(+ "(function() { var _jref = ("
  ;             args[0]
  ;             "); return (typeof _jref !== 'undefined' && _jref !== null) })()"))))
  "exists": (fn args            ; todo multiple args
    (if (assertForm args 1 1)
        `(,(+ "(typeof " (pr args[0]) " !== 'undefined' && " (pr args[0]) " !== null)"))))
  ; keywords
  "in": (fn args
    ; todo more than 2 args (concat / spread?)
    (if (assertForm args 2 2)
        `(,(+ "([].indexOf.call("
              (pr args[1]) ", " (pr args[0]) ") >= 0)"))))
  "of": (makeop "in" undefined 2 2)
  "new": (fn args
    (if (assertForm args 1)
        `(,(+ "new " (pr (args.shift)) "(" (spr args) ")"))))
  ; reserved
    ; "var" -- throws compile error without var, todo fix
    ; "class"
  "function": (fn (reserved "function"))
  "with":     (fn (reserved "with"))
))

(= ops `(
; todo un-retardify chained comparisons
; in JS, 3 < 2 < 1 produces true (facepalm)
; todo ops like += should take multiple ars and compile into one += and multiple +
  ; arithmetic
  ("+" undefined 1 Infinity yes) ("-" undefined 1) ("*" 1) ("/" 1) ("%" undefined 1)
  ; logical
  ("?"   "exists") ("==" "is")  ("===" "is") ("!=" "isnt")
  ("!==" "isnt")   ("&&" "and") ("||"  "or") ("!"  "not")
  ; comparison
  (">"   undefined 2) ("<"    undefined 2)
  (">="  undefined 2) ("<="   undefined 2)
  ; bitwise
  ("&"   undefined 2) ("|"    undefined 2) ("^"   undefined 2)
  ("<<"  undefined 2) (">>"   undefined 2) (">>>" undefined 2)
  ; assignment
  ("+="  undefined 2) ("-="   undefined 2) ("*="  undefined 2)
  ("/="  undefined 2) ("%="   undefined 2) ("<<=" undefined 2)
  (">>=" undefined 2) (">>>=" undefined 2) ("&="  undefined 2)
  ("^="  undefined 2) ("|="   undefined 2)
  ; words and keywords
  ("instanceof" undefined 2 2)
  ; other
  ("," undefined 2 2)  ; bugs out due to lexer dropping empty cells
))

(for op ops
     (if (is (typeof op[1]) "string")
         (= operators[op[0]] operators[op[1]])
         (= operators[op[0]] (makeop ...op))))

(= singops `(
  ("not" "!") ("~" "~") ("delete" "delete") ("typeof" "typeof")
))

(for op singops (= operators[op[0]] (makesing op[1])))

(= stateops `(
  ("return" 0 1) ("break" 0 1) ("continue" 0 0) ("throw" 1 1)
))

(for op stateops (= operators[op[0]] (makestate op[0])))

; Export operators
(= exports.operators operators)


; # Operator functions
; When operators like > are passed around, the compiler checks against
; the opFuncs store. If it has an element by that name, that function
; is hoisted and embedded in compiled JavaScript by calling .toString
; on it. References in compiled code are renamed into the .name
; property of the corresponding opFuncs element.

; Unfinished. ToDo implement

(mac macMakeOp name op zv
; <func-name> <operator> <zero-value>
     `(def ,name â€¦args
           ,(if (? zv)
                `(do (args.unshift ,zv)
                     (if (is args.length 0)
                         ,zv
                         (args.reduce {,op #0 #1})))
                `(if (isnt args.length 0)
                     (args.reduce {,op #0 #1})))))

(= opFuncs (:))

; Before we start putting these into opFuncs, main compiler needs to
; learn to only check for opFuncs when operator is not first in list

(macMakeOp add + 0)
(macMakeOp sub - 0)
(macMakeOp mul * 1)
(macMakeOp div / 1)

; (console.log (div 10))
; (console.log (add.toString))

; Export
(= exports.opFuncs opFuncs)
