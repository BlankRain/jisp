; Built-in macros

; Default macros to add:
  ; (test x (case func0 body) (case func1 body)) -> applies func in each case, expands to series of elifs; tests for equality against literals and for type against undefined
  ; (any) -> a sliding switch (or (if (? x) x) (if (? y) y) ...)
  ; ...

(= util (require "./util"))

(def checkVar exp
  (if (util.assertExp exp util.isVarName "valid identifier")
       exp))

(mac macOneArg name rest
  `(if (or (?! ,name) (> (get ,rest length) 0))
       (throw (Error "expecting one argument"))))

; `car`: x[0]
; `head`: x[0]
(mac macCar x ...other (do
  (macOneArg x other)
  `(get ,x 0)))

(= exports.car macCar)
(= exports.head macCar)

; `cdr`: x.slice(1)
; `tail`: x.slice(1)
(mac macCdr x ...other (do
  (macOneArg x other)
  `((get ,x slice) 1)))

(= exports.cdr macCdr)
(= exports.tail macCdr)

; `init`: x.slice(0, -1)
(mac macInit x ...other (do
  (macOneArg x other)
  `((get ,x slice) 0 -1)))

(= exports.init macInit)

; `last`: x.slice(-1)[0]
(mac macLast x ...other (do
  (macOneArg x other)
  `(get ((get ,x slice) -1) 0)))

(= exports.last macLast)

; `let`: self-executing lambda with auto-passed arguments
(mac macLet ...args body (do
  (util.assertExp args (fn x (is (% x.length 2) 0))
                          "an even number of arguments")
  (if (?! body) (= body `()))
  (= names    `()
     callArgs `())
  (while (> args.length 0)
    (do (names.push (checkVar (args.shift)))
        (callArgs.push (args.shift))))
  `((fn ,...names ,body) ,...callArgs)))

(= exports.let macLet)

; `?!`: (not (? x))
(mac macNotExist x ...other (do
  (macOneArg x other)
  `(not (? ,x))))

(= exports["?!"] macNotExist)

; `isa`: (is (typeof x) y)
(mac macIsA obj ...types
  `(is (typeof ,obj) ,...types))

(= exports.isa macIsA)

; `any`: picks first existing value
(mac macAny ...values
  `(or ,...(for value values
    `(and (? ,value) ,value))))

(= exports.any macAny)
