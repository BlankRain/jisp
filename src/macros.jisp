; Built-in macros

; Default macros to add:
  ; (test x (case func0 body) (case func1 body)) -> applies func in each case, expands to series of elifs; tests for equality against literals and for type against undefined
  ; (any) -> a sliding switch (or (if (? x) x) (if (? y) y) ...)
  ; ...

(= util (require "./util"))

(def checkVar exp
  (if (util.assertExp exp util.isVarName "valid identifier")
       exp))

; `let`: self-executing lambda with auto-passed arguments
(mac macLet ...args body (do
  (util.assertExp args (fn x (is (% x.length 2) 0))
                          "an even number of arguments")
  (if (not (? body)) (= body `()))
  (= names    `()
     callArgs `())
  (while (> args.length 0)
    (do (names.push (checkVar (args.shift)))
        (callArgs.push (args.shift))))
  `((fn ,...names ,body) ,...callArgs)))

(= exports.let macLet)

; `?!`: (not (? x))
(mac macNotExist ...args (do
  (util.assertExp args (fn x (is x.length 1)) "one argument")
  `(not (? ,(car args)))))

(= (get exports "?!") macNotExist)

; `isa`: (is (typeof x) y)
(mac macIsA obj type (do
  `(is (typeof ,obj) ,type)))

(= exports.isa macIsA)
